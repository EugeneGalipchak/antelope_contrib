
# dbcentral
#
# GUI utility to keep track of databases and launch commands on them
#
# Kent Lindquist 
# Lindquist Consulting
# July, 2002

package require Tclx
lappend auto_path $env(ANTELOPE)/data/tcl/library

proc init_globals {} {
	global Template_time Template_time_format 
	global Nicknames Tasks Commands
	
	set Template_time_format "%m/%d/%Y %H:%M:%S.%s %Z"

	set Template_time [epoch2str [str2epoch now] $Template_time_format]

	pfgetarr Nicknames %dbcentral

	foreach nickname [array names Nicknames] {

		set tasklines [pfgetlist @dbcentral#$nickname#tasks]

		foreach taskline $tasklines {

			set parts [split $taskline]
			set task [lindex $parts 0]
			set runline [join [lrange $parts 1 end]]

			lappend Tasks($nickname) $task

			set Commands($nickname,$task) "$runline"
		}
	}
}

proc init_windows {} {

	global Template_time Nicknames Tasks Commands

	label .timelbl -text "Time: " -bg beige

	entry .template_time -textvariable Template_time \
		 	     -relief sunken -width 26 -bg beige
	
	bind .template_time <KeyPress-Return> normalize_template_time

	grid .timelbl .template_time -sticky ew
	grid columnconfigure . 0 -weight 0
	grid columnconfigure . 1 -weight 1

	foreach nickname [array names Nicknames] {

		set buttonname .b$nickname
		regsub -all " " $buttonname _ buttonname

		set menuname $buttonname.m

		menubutton $buttonname -text $nickname \
			 -relief raised -menu $menuname \
			 -direction flush -bg beige \
			 -activebackground orange
		menu $menuname -tearoff 0

		bind $buttonname <Button-3> "show_path {$nickname} $buttonname"
		bind $buttonname <ButtonRelease-3> "unshow_path $buttonname"

		foreach task $Tasks($nickname) {

			set cmd "myexec {$nickname} {$task}"

			$menuname add command -label $task \
				-command $cmd \
				-background lightblue \
				-activebackground lightyellow
		}

		grid $buttonname -sticky ew -columnspan 2
	}

	button .quit -text Quit -command "destroy ." -bg red
	grid .quit -sticky ew -columnspan 2

	wm resizable . 0 0
}

proc normalize_template_time {} {
	global Template_time Template_time_format

	if { [catch "set time [str2epoch $Template_time]" error] } {
		tkdialog .err "Conversion problem" \
		  "Couldn't convert time string. Resetting to current time." \
		   OK 
		
		set time [str2epoch now]
	} 
	set Template_time [epoch2str $time $Template_time_format]
}

proc get_dbpath { nickname } {
	global Template_time

	set time [str2epoch $Template_time]

	pfgetarr myarray %dbcentral#$nickname
	set dbname_template [lindex [array get myarray dbname_template] 1]

	set dbname [epoch2str $time $dbname_template]

	return $dbname
}

proc unshow_path { w } {
	destroy .path

	$w configure -width 0
}

proc show_path { nickname w } {
	
	set dbname [get_dbpath $nickname]

	set width [winfo width $w]

	if { [info exists .path] } {
		destroy .path
	}
	label .path -text $dbname -bg yellow -font [font create -size 10]

	set reqwidth [winfo reqwidth .path]
	if { $reqwidth > $width } {
		$w configure -width [clength $dbname]
		update
	}

	set width [winfo width $w]
	set height [winfo height $w]
	set x [expr $width / 2]
	set y [expr $height / 2]

	place .path -anchor center -in $w -x $x -y $y 

}

proc myexec { nickname task } {
	global Commands

	set dbname [get_dbpath $nickname]

	set cmd_template $Commands($nickname,$task)

	regsub -all DBNAME $cmd_template $dbname command

	eval exec $command &
}

proc run_cmdline {} {
	global argc argv
	global Template_time Template_time_format
	global Nicknames Tasks Commands

	set i 0
	set n [llength $argv]

	set List_Nicknames 0
	set Resolve_dbname 0

	set stripped_argv {}

	while { $i < $n } {
		set myarg [lindex $argv $i]
		if { [cequal $myarg -n] } {
			set List_Nicknames 1
		} elseif { [cequal $myarg -t] } {
			incr i
			set time [lindex $argv $i]
			set Template_time [epoch2str [str2epoch $time] \
					   $Template_time_format]
		} elseif { [cequal $myarg -d] } {
			set Resolve_dbname 1
		} else {
			lappend stripped_argv $myarg
		}
		incr i
	}

	if { [llength $stripped_argv] >= 1 } {
		
		set nickname [lindex $stripped_argv 0]

	} else {

		set nickname ""
	}

	if { [llength $stripped_argv] >= 2 } {
		
		set task [lindex $stripped_argv 1]

	} else {

		set task ""
	}

	if { $nickname != "" } {
	  if { ! [info exists Tasks($nickname)] ||
	     [llength $Tasks($nickname)] <= 0 } {

		puts stderr \
		  "\ndbcentral: No tasks defined for database '$nickname'\n"
		exit -1
	  }
	}

	if { $task != "" &&
	     ! [info exists Commands($nickname,$task)] } {

		puts stderr \
		  "\ndbcentral: No task '$task' defined for database '$nickname'\n"
		exit -1

	}

	if { $List_Nicknames && $nickname != "" } {

		puts stdout "\ndbcentral command nicknames for $nickname:\n\n"

		foreach key $Tasks($nickname) {
			puts stdout "\t$key\n"
		}
		puts stdout "\n"

	} elseif { $List_Nicknames } {

		puts stdout "\ndbcentral database nicknames:\n\n"
		
		foreach key [array names Nicknames] {
			puts stdout "\t$key\n"
		}
		puts stdout "\n"

	} elseif { $Resolve_dbname && $nickname == "" } {

		puts stderr "Must specify a database nickname with -d\n"
		exit -1

	} elseif { $Resolve_dbname } {

		puts stdout [get_dbpath $nickname]	

	} elseif { [llength $stripped_argv] == 1 } {

		set task [lindex $Tasks($nickname) 0]

		myexec $nickname $task

	} elseif { [llength $stripped_argv] == 2 } {

		myexec $nickname $task

	} else {

		puts stderr {Usage: dbcentral [-n] [-t timestring] [-d] [database_nickname [task_nickname]]}
	}

}

init_globals

if { $argc == 0 } {

	init_windows

} else {

	wm withdraw .

	run_cmdline

	exit 0
}
