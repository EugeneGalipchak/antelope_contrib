# dbcentral
#
# GUI utility to keep track of databases and launch commands on them
#
#   Copyright (c) 2002-2005 Lindquist Consulting, Inc.
#   All rights reserved. 
#                                                                     
#   Written by Dr. Kent Lindquist, Lindquist Consulting, Inc. 
# 
#   This software may be used freely in any way as long as 
#   the copyright statement above is not removed. 


package require Tclx
lappend auto_path $env(ANTELOPE)/data/tcl/library

proc init_globals {} {
	global Template_time Template_time_format 
	global Nicknames Tasks Commands
	global Dbcentral_dbname Db
	
	set Template_time_format "%m/%d/%Y %H:%M:%S.%s %Z"

	set Template_time [epoch2str [str2epoch now] $Template_time_format]

	set Dbcentral_dbname [pfget dbcentral dbcentral_database]
	set default_tasklines [pfgetlist @dbcentral#default_tasks]

	if { ! [file exists $Dbcentral_dbname] } {
		
		elog_die "Can't find database '$Dbcentral_dbname' specified in parameter file"
	}

	set Db [dbopen $Dbcentral_dbname r]
	set Db [dblookup $Db 0 clusters 0 0]

	set dbclusters [dbsort -u $Db clustername]

	set nclusters [dbquery $dbclusters dbRECORD_COUNT]

	pfgetarr custom_tasks %dbcentral#custom_tasks

	for { set i 0 } { $i < $nclusters } { incr i } {

		set nickname [dbgetv $dbclusters 0 $i clustername]

		lappend Nicknames $nickname

		if { [lsearch -exact [array names custom_tasks] $nickname] > -1 } {

			set tasklines [pfgetlist @dbcentral#custom_tasks#$nickname]

			set_tasks $nickname $tasklines

		} else {

			set_tasks $nickname $default_tasklines
		}
	}
}

proc init_windows {} {

	global Template_time Nicknames Tasks Commands Cmdline

	set Cmdline 0

	bind . <Control-KeyPress-c> "destroy ."
	bind . <Control-KeyPress-C> "destroy ."

	frame .mb -background beige

	menubutton .mb.file -bg beige -text File -underline 0 \
		   -menu .mb.file.m -highlightthickness 0
	
	menu .mb.file.m -tearoff 0 -bg beige

	.mb.file.m  add command -label Quit -underline 0 -command "destroy ."

	pack .mb.file -side left

	menubutton .mb.options -bg beige -text Options -underline 0 \
		   -menu .mb.options.m -highlightthickness 0
	
	menu .mb.options.m -tearoff 0 -bg beige

	pack .mb.options -side left

	grid .mb -sticky ew -columnspan 2 

	button .timelbl -text "Time: " -bg lemonchiffon2 -command {
		global Template_time
		set Template_time [epoch2str [str2epoch now] $Template_time_format]
	}

	entry .template_time -textvariable Template_time \
		 	     -relief sunken -width 26 -bg beige
	
	bind .template_time <KeyPress-Return> normalize_template_time

	grid .timelbl .template_time -sticky ew
	grid columnconfigure . 0 -weight 0
	grid columnconfigure . 1 -weight 1

	foreach nickname [lsort $Nicknames] {

		set buttonname .b$nickname
		regsub -all " " $buttonname _ buttonname

		set menuname $buttonname.m

		menubutton $buttonname -text $nickname \
			 -relief raised -menu $menuname \
			 -direction flush -bg beige \
			 -activebackground orange
		menu $menuname -tearoff 0

		bind $buttonname <Button-2> "show_path {$nickname} $buttonname"
		bind $buttonname <ButtonRelease-2> "unshow_path $buttonname"

		foreach task $Tasks($nickname) {

			set cmd "myexec {$nickname} {$task}"

			$menuname add command -label $task \
				-command $cmd \
				-background lightblue \
				-activebackground lightyellow
		}

		bind $buttonname <Button-3> "$menuname invoke 0"

		grid $buttonname -sticky ew -columnspan 2
	}

	wm resizable . 0 0
}

proc set_tasks { nickname tasklines } {
	global Commands Tasks	

	foreach taskline $tasklines {

		set parts [split $taskline]
		set task [lindex $parts 0]
		set runline [join [lrange $parts 1 end]]

		lappend Tasks($nickname) $task

		set Commands($nickname,$task) "$runline"
	}
}

proc normalize_template_time {} {
	global Template_time Template_time_format

	if { [catch "set time [str2epoch $Template_time]" error] } {
		tkdialog .err "Conversion problem" \
		  "Couldn't convert time string. Resetting to current time." \
		   OK 
		
		set time [str2epoch now]
	} 
	set Template_time [epoch2str $time $Template_time_format]
}

proc get_dbpath { nickname } {
	global Template_time Db  Cmdline

	set time [str2epoch $Template_time]

	set expr "clustername == \"$nickname\" && time <= $time && "
	append expr "(endtime == NULL || endtime >= $time)"

	set dbcluster [dbsubset $Db $expr]

	if { [dbquery $dbcluster dbRECORD_COUNT] <= 0 } {
		
		set msg "No database for clustername '$nickname' at time " 
		append msg [strtime $time]
		append msg " UTC"

		if { ! $Cmdline } {
			tkdialog .err "Database not found" $msg OK
		}
		
		set dbname ""

	} else {
		
		set dbcluster [lreplace $dbcluster 3 3 0]

		set dbname_template [dbeval $dbcluster "extfile()"]

		set dbname [epoch2str $time $dbname_template]
	}

	return $dbname
}

proc unshow_path { w } {

	destroy .path

	$w configure -width 0
}

proc show_path { nickname w } {
	
	set dbname [get_dbpath $nickname]

	if { $dbname == "" } {

		return
	}

	set width [winfo width $w]

	if { [info exists .path] } {
		destroy .path
	}

	label .path -text $dbname -bg yellow -font [font create -size 10]

	set reqwidth [winfo reqwidth .path]
	if { $reqwidth > $width } {
		$w configure -width [clength $dbname]
		update
	}

	set width [winfo width $w]
	set height [winfo height $w]
	set x [expr $width / 2]
	set y [expr $height / 2]

	place .path -anchor center -in $w -x $x -y $y 
}

proc myexec { nickname task } {
	global Commands

	set dbname [get_dbpath $nickname]

	if { $dbname != "" } {

		set cmd_template $Commands($nickname,$task)

		regsub -all DBNAME $cmd_template $dbname command

		eval exec $command &
	}
}

proc run_cmdline {} {
	global argc argv
	global Template_time Template_time_format
	global Nicknames Tasks Commands
	global Cmdline

	set Cmdline 1

	set i 0
	set n [llength $argv]

	set List_Nicknames 0
	set Resolve_dbname 0
	set Time_specified 0

	set stripped_argv {}

	while { $i < $n } {
		set myarg [lindex $argv $i]
		if { [cequal $myarg -n] } {
			set List_Nicknames 1
		} elseif { [cequal $myarg -t] } {
			incr i
			if { $i == $n } {
				puts stderr "\ndbcentral: Must specify a time string with -t\n"
				exit -1
			}
			set time [lindex $argv $i]
			set Template_time [epoch2str [str2epoch $time] \
					   $Template_time_format]
			set Time_specified 1
		} elseif { [cequal $myarg -d] } {
			set Resolve_dbname 1
		} else {
			lappend stripped_argv $myarg
		}
		incr i
	}

	if { [llength $stripped_argv] >= 1 } {
		
		set nickname [lindex $stripped_argv 0]

	} else {

		set nickname ""
	}

	if { [llength $stripped_argv] >= 2 } {
		
		set task [lindex $stripped_argv 1]

	} else {

		set task ""
	}

	if { $nickname != "" } {
	  if { ! [info exists Tasks($nickname)] ||
	     [llength $Tasks($nickname)] <= 0 } {

		puts stderr \
		  "\ndbcentral: No tasks defined for database '$nickname'\n"
		exit -1
	  }
	}

	if { $task != "" &&
	     ! [info exists Commands($nickname,$task)] } {

		puts stderr \
		  "\ndbcentral: No task '$task' defined for database '$nickname'\n"
		exit -1

	}

	if { $List_Nicknames && $nickname != "" } {

		puts stdout "\ndbcentral command nicknames for $nickname:\n"

		foreach key $Tasks($nickname) {
			puts stdout "\t$key"
		}
		puts stdout "\n"

	} elseif { $List_Nicknames } {

		puts stdout "\ndbcentral database clusternames:\n"
		
		foreach key $Nicknames {
			puts stdout "\t$key"
		}
		puts stdout "\n"

	} elseif { $Resolve_dbname && $nickname == "" } {

		puts stderr "\ndbcentral: Must specify a database nickname when using -d\n"
		exit -1

	} elseif { $Resolve_dbname } {

		puts stdout [get_dbpath $nickname]	

	} elseif { [llength $stripped_argv] == 0 && $Time_specified } {

		puts stderr "\ndbcentral: Must specify a database nickname when using -t\n"
		exit -1

	} elseif { [llength $stripped_argv] == 1 } {

		set task [lindex $Tasks($nickname) 0]

		myexec $nickname $task

	} elseif { [llength $stripped_argv] == 2 } {

		myexec $nickname $task

	} else {

		puts stderr {Usage: dbcentral [-n] [-t timestring] [-d] [database_nickname [task_nickname]]}
		exit -1
	}
}

init_globals

if { $argc == 0 && ! [info exists tk_version] } {

	exec $env(ANTELOPE)/bin/awish $argv0

} elseif { $argc == 0 } {

	init_windows

} else {

	run_cmdline

	exit 0
}
