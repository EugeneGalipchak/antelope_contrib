.TH DATASCOPE_PHP 3 "$Date$"
.SH NAME
Datascope_PHP \- Datascope interface for PHP
.SH SYNOPSIS
.nf

<?php
\fBdl\fP('Datascope.so')
?>

.fi
.SH DESCRIPTION

The Datascope interface for PHP is under development, intended to
parallel the Perl interface to Datascope. For information
contact kent@lindquistconsulting.com.

These extensions must first be loaded with a \fBdl\fP statement:
.ft CW
.in 2c
.nf

\fBdl('Datascope.so');\fP

.fi
.in
.ft R
.LP

The following functions have been implemented. Since these functions
are wrappers around the respective C function calls, the documentation
on the identically-named C routines may also be helpful.

.SS Datascope functions
.IP "\fBds_dbopen\fP ( database, permissions )"
Returns a database pointer to the specified database.
.ft CW
.in 2c
.nf

$db = ds_dbopen ( $database, 'r+' ) ;

.fi
.in
.ft R
.IP "\fBdblookup\fP ( $db, database, table, field, record )"
Returns a database pointer for the specified database, table, field,
and record. The names should be specified as strings, or left
as empty strings to leave desired parts of the pointer untouched, where
possible).
.ft CW
.in 2c
.nf

$db = dblookup( $db, '', 'wfdisc', '', '' ) ;

.fi
.in
.ft R
.IP "\fBdbgetv\fP ( $db, field_name, [field_name, ...] )"
Returns the values of the specified fields for a particular record:
.ft CW
.in 2c
.nf
.ne 4

list( $sta, $chan, $time ) =
        dbgetv( $db, 'sta', 'chan', 'time' );

.fi
.in
.ft R
For a database pointer, like \fBbundle\fP from dbgroup(3), use the
following syntax:
.ft CW
.in 2c
.nf

$dbbundle = dbgetv( $db, 'bundle' );
$dbbundle = split ( ' ', $dbbundle ) ;

.fi
.in
.ft R
.IP "\fBtrloadchan\fP ( $db, t0, t1, sta, chan )"
read channel waveform data
.ft CW
.in 2c 
.nf

$tr = trloadchan( $db, $t0, $t1, $sta, $chan );

.fi
.in
.ft R
.IP "\fBtrextract_data\fP ( $tr )"
read channel waveform data
.ft CW
.in 2c 
.nf

$rawdatapoints = trextract_data( $tr );

.fi
.in
.ft R
.IP "\fBtrfree\fP ( $tr )"
free a trace-object pointer
.ft CW
.in 2c 
.nf

trfree( $tr );

.fi
.in
.ft R
.IP "\fBdb2xml\fP ( $db [, flags [, rootnode [, rownode [, fields [, expressions]]]]] )"
Return an eXtensible Markup Language (XML) representation of a datascope view via the db2xml(3) command. The flags argument may be empty or DBXML_PRIMARY, in
which case only the primary keys are returned.
.fi CW
.in 2c
.nf
.ne 4

$xml = db2xml( $db );

.fi
.in
.ft R
.IP "\fBdbex_eval\fP ( $db, expression )"
Evaluate an expression for a particular record.
.ft CW
.in 2c
.nf

$distance = dbex_eval ( $db,
            'distance( lat, lon, site.lat, site.lon )' ) ;

.fi
.in
.ft R
.IP "\fBdbextfile\fP( $db [, base-table] )"
return the filename for an external file for a particular record in
a view, for a particular base-table if specified.
.ft CW
.in 2c
.nf

$filename = dbextfile( $db ) ;

.fi
.in
.ft R
.IP "\fBdbfind\fP ( $db, $expression, [, $first [, $reverse]] )"
Find the first record in the specified database that matches the 
given expression. The search starts from the record indicated by the
database pointer unless $first is specified, and proceeds 
forwards unless $reverse is given as non-zero.
.ft CW
.in 2c
.nf

$record = dbfind( $db, "sta == \\"PFO\\"" ) ;
$db[3] = $record;

.fi
.in
.ft R
.IP "\fBdbaddv\fP ( $db, field_name, value, [field_name, value, ...] )"
Add a new record with the specified values to the database.
New records are checked to insure the keys are filled out and don't
conflict with other records in the table.
If the id key in a defining table (orid in the origin table, for example)
is not specified, a new id is automatically generated, using dbnextid.
.ft CW
.in 2c
.nf

.ne 6

$new = dbaddv( $dbevent, 'evid', 1,
            'evname', 'fake',
            'prefor', 1,
            'auth', 'danq' ) ;

.fi
.in
.ft R
.IP "\fBdbaddnull\fP ( $db )"
Add a null record to the specified table, returning the record number 
of the added row.
.ft CW
.in 2c
.nf
.ne 3

$recno =  dbaddnull( $db );

.fi
.in
.ft R
.IP "\fBdbputv\fP ( $db, field_name, value, [field_name, value, ...] )"
Change the fields for an existing record to the specified values.
.ft CW
.in 2c
.nf

.ne 6

dbputv( $dbevent, 'evid', 1,
                  'evname', 'fake',
                  'prefor', 1,
                  'auth', 'danq' ) ;

.fi
.in
.ft R
.IP "\fBdbadd\fP ( $db [, record] )"
Add a record from the scratch record, or from the specified string
.ft CW
.in 2c
.nf

$recno = dbadd( $db ) ;

.fi
.in
.ft R
.IP "\fBdbsubset\fP ( $db, expression )"
returns a new view which is the set of all row which satisfy the expression
.ft CW
.in 2c
.nf

$dbsubsetted = dbsubset ( $dbwfdisc, 'sta=="AAK"' ) ;

.fi
.in
.ft R
.IP "\fBdbprocess\fP ( $db, cmd1, cmd2, cmd3 ... )"
returns a new view which is the result of applying the dbprocess
commands cmd1, cmd2, etc to the input database pointer.
.ft CW
.in 2c
.nf

$dbprocess = dbprocess ( $db, 'dbopen wfdisc',
                              'dbjoin site',
                              'dbsubset distance(38,-104,lat,lon)<15') ;

.fi
.in
.ft R
.IP "\fBdbquery\fP ( $db, code )"
Query the database for information. The standard Datascope codes must
be in quotes.
.ft CW
.in 2c
.nf

.ne 6

$nrecords =  dbquery( $db, 'dbRECORD_COUNT' ) ;
$description = dbquery( $db, 'dbTABLE_DESCRIPTION' ) ;
$detail = dbquery( $db, 'dbTABLE_DETAIL' ) ;
$ntables = dbquery( $db, 'dbTABLE_COUNT' ) ;

.fi
.in
.ft R
.IP "\fBdbnrecs\fP ( $db )"
Return the number of records in a table or view. This function is
shorthand for dbquery( $db, 'dbRECORD_COUNT' );
.ft CW
.in 2c
.nf
.ne 3

$nrecords =  dbnrecs( $db );

.fi
.in
.ft R
.IP "\fBds_dbclose\fP ( $db )"
Close a Datascope database
.ft CW
.in 2c
.nf

ds_dbclose ( $db );

.fi
.in
.ft R
.IP "\fBdbfree\fP ( $db )"
Free Datascope memory
.ft CW
.in 2c
.nf

dbfree ( $db );

.fi
.in
.ft R
.IP "\fBdbdestroy\fP ( $db )"
Destroy all tables of a Datascope database
.ft CW
.in 2c
.nf

dbdestroy ( $db );

.fi
.in
.ft R
.IP "\fBdbtruncate\fP ( $db, $nrecords )"
Truncate a database table to the specified number of records
.ft CW
.in 2c
.nf

dbtruncate ( $db, $nrecords ) ;

.fi
.in
.ft R
.IP "\fBdbresponse\fP ( $filename )"
Returns a PHP resource for a response object, representing the 
instrument response curve defined in $filename. This resource 
may be subsequently queried with \fBeval_response\fP.
.ft CW
.in 2c
.nf

$response = dbresponse( $filename ) ;

.fi
.in
.ft R
.IP "\fBeval_response\fP ( $response, $omega )"
Evaluates a response object at the specified angular frequency, 
returning the real and imaginary components of the response
.ft CW
.in 2c
.nf

$pi = 3.1415;
$f_hz = 5; 

$cx = eval_response( $response, 2 * $pi * $f_hz );

$real = $cx[0];
$imag = $cx[1];

.fi
.in
.ft R
.IP "\fBstrtdelta\fP ( $epoch )"
Convert an elapsed time in seconds to a string representation
.ft CW
.in 2c
.nf

$elapsed = strtdelta ( $epoch );

.fi
.in
.ft R

.SH EXAMPLE
.ft CW
.in 2c
.nf

.ne 16

#!/bin/sh
exec /usr/local/bin/php -f $0

<?php
if(!extension_loaded('Datascope')) {
        dl('Datascope.so');
}
$module = 'Datascope';
$functions = get_extension_funcs($module);
echo "Functions available in the test extension:<br>\\n";
foreach($functions as $func) {
    echo $func."<br>\\n";
}
echo "<br>\\n";

.ne 6
$mydb =ds_dbopen( "/opt/antelope/data/db/demo/demo", "r" );

$mydb = dbprocess( $mydb, "dbopen origin",
                          "dbsubset ml > 3" );
echo "table has ", dbnrecs( $mydb ),
     " records after subset\\n";

.ne 5
$mydb[3] = 0;
list( $lat, $lon, $ndef, $auth, $lddate ) =
    dbgetv( $mydb, "lat", "lon", "ndef", "auth", "lddate" );

echo "$lat, $lon, $ndef, $auth, $lddate\\n";

.ne 6
$moo = dbex_eval( $mydb, "lat + lon" );

echo var_dump( $moo ), "\\n";

$moo = dbquery( $mydb, "dbVIEW_TABLES" );
echo var_dump( $moo ), "\\n";

?>

.fi
.in
.ft R
.SH LIBRARY
.SH "SEE ALSO"
.nf
perldb(3P)
.fi
.SH "BUGS AND CAVEATS"

WARNING: This is an unfinished prototype!!

.SH AUTHOR
.nf
Kent Lindquist
Lindquist Consulting
.fi
.\" $Id$
