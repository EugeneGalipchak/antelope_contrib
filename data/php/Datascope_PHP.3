.TH DATASCOPE_PHP 3 "$Date$"
.SH NAME
Datascope_PHP \- Datascope interface for PHP
.SH SYNOPSIS
.nf

<?php
\fBdl\fP('Datascope.so')
?>

.fi
.SH DESCRIPTION

The Datascope interface for PHP is under development, intended to
parallel the Perl interface to Datascope. For information
contact kent@lindquistconsulting.com.

These extensions must first be loaded with a \fBdl\fP statement:
.ft CW
.in 2c
.nf

\fBdl('Datascope.so');\fP

.fi
.in
.ft R
.LP

The following functions have been implemented. Since these functions
are wrappers around the respective C function calls, the documentation
on the identically-named C routines may also be helpful.

.SS Datascope functions
.IP "\fBds_dbopen\fP ( database, permissions )"
Returns a database pointer to the specified database.
.ft CW
.in 2c
.nf

$db = ds_dbopen ( $database, 'r+' ) ;

.fi
.in
.ft R
.IP "\fBds_dbopen_database\fP ( database, permissions )"
Returns a database pointer to the specified database. Same as ds_dbopen
except it also understands a full table pathname, in which case the 
returned pointer will point to the opened table. 
.ft CW
.in 2c
.nf

$db = ds_dbopen_database ( $database, 'r+' ) ;

.fi
.in
.ft R
.IP "\fBds_dbopen_table\fP ( database, permissions )"
Returns a database pointer to the specified database table. A name of "-" 
reads from stdin. 
.ft CW
.in 2c
.nf

$db = ds_dbopen_table ( $database, 'r+' ) ;

.fi
.in
.ft R
.IP "\fBds_dbtmp\fP ( schema )"
Returns a database pointer to a temporary database of the specified schema
.ft CW
.in 2c
.nf

$db = ds_dbtmp ( 'rt1.0' ) ;

.fi
.in
.ft R
.IP "\fBds_dbcreate\fP ( filename [, schema [, dbpath [, description [, detail ]]]] )"
Create a database descriptor in the specified filename. 
.ft CW
.in 2c
.nf

$db = ds_dbcreate ( 'sample_database', 'rt1.0', 
		    'opt/antelope/data/db/demo/{demo}' ) ;

.fi
.in
.ft R
.IP "\fBdblookup\fP ( $db, database, table, field, record )"
Returns a database pointer for the specified database, table, field,
and record. The names should be specified as strings, or left
as empty strings to leave desired parts of the pointer untouched, where
possible).
.ft CW
.in 2c
.nf

$db = dblookup( $db, '', 'wfdisc', '', '' ) ;

.fi
.in
.ft R
.IP "\fBdbgetv\fP ( $db, field_name, [field_name, ...] )"
Returns the values of the specified fields for a particular record:
.ft CW
.in 2c
.nf
.ne 4

list( $sta, $chan, $time ) =
        dbgetv( $db, 'sta', 'chan', 'time' );

.fi
.in
.ft R
For a database pointer, like \fBbundle\fP from dbgroup(3), use the
following syntax:
.ft CW
.in 2c
.nf

$dbbundle = dbgetv( $db, 'bundle' );
$dbbundle = split ( ' ', $dbbundle ) ;

.fi
.in
.ft R
.IP "\fBpfget\fP ( pfname, key )"
Get the value for the named key in the parameter named pfname. pfget
takes either single parameter names, or extended-syntax names in the 
style of pfresolve(3). If the requested parameter is a parameter-file
table or array, the result is returned as a PHP array or associative-array, 
with nested structures where appropriate. If the key is left as the 
empty string, the entire parameter file is returned as a nested 
data structure. 

.nf

print pfget( "dbrecenteqs", "max_num_eqs" ) . "\\n";
print pfget( "dbrecenteqs", "other_region_links{Hawaii}" ) . "\\n";

print_r pfget( "dlmon", "" );

.fi
.in
.ft R
.IP "\fBpfget_boolean\fP ( pfname, key )"
Get the value for the named key in the parameter named pfname and interpret 
it as a boolean value, i.e. "no", "0", "false" return a value of 0; 
"yes", "1", "true" return a value of true (usually -1). 
.nf

print pfget_boolean( "trdefaults", "miniseed_sparc_order" ) . "\\n";

.fi
.in
.ft R
.IP "\fBtrloadchan\fP ( $db, t0, t1, sta, chan )"
read channel waveform data
.ft CW
.in 2c 
.nf

$tr = trloadchan( $db, $t0, $t1, $sta, $chan );

.fi
.in
.ft R
.IP "\fBtrapply_calib\fP ( $tr )"
multiply waveform data in  trace  object by calib value
.ft CW
.in 2c 
.nf

trapply_calib( $tr );

.fi
.in
.ft R
.IP "\fBtrextract_data\fP ( $tr )"
read channel waveform data
.ft CW
.in 2c 
.nf

$rawdatapoints = trextract_data( $tr );

.fi
.in
.ft R
.IP "\fBtrsplit\fP ( $tr )"
break up waveform records at marked bad data
.ft CW
.in 2c 
.nf

trsplit( $tr );

.fi
.in
.ft R
.IP "\fBtrsplice\fP ( $tr )"
splice together data segments (input trace-object must be 
pre-sorted by sta, chan, and time)
.ft CW
.in 2c 
.nf

trsplice( $tr );

.fi
.in
.ft R
.IP "\fBtrfree\fP ( $tr )"
free a trace-object pointer
.ft CW
.in 2c 
.nf

trfree( $tr );

.fi
.in
.ft R
.IP "\fBdb2xml\fP ( $db [, flags [, rootnode [, rownode [, fields [, expressions]]]]] )"
Return an eXtensible Markup Language (XML) representation of a datascope view via the db2xml(3) command. The flags argument may be empty or DBXML_PRIMARY, in
which case only the primary keys are returned.
.fi CW
.in 2c
.nf
.ne 4

$xml = db2xml( $db );

.fi
.in
.ft R
.IP "\fBdbex_eval\fP ( $db, expression )"
Evaluate an expression for a particular record.
.ft CW
.in 2c
.nf

$distance = dbex_eval ( $db,
            'distance( lat, lon, site.lat, site.lon )' ) ;

.fi
.in
.ft R
.IP "\fBdbextfile\fP( $db [, base-table] )"
return the filename for an external file for a particular record in
a view, for a particular base-table if specified.
.ft CW
.in 2c
.nf

$filename = dbextfile( $db ) ;

.fi
.in
.ft R
.IP "\fBdbfind\fP ( $db, $expression, [, $first [, $reverse]] )"
Find the first record in the specified database that matches the 
given expression. The search starts from the record indicated by the
database pointer unless $first is specified, and proceeds 
forwards unless $reverse is given as non-zero.
.ft CW
.in 2c
.nf

$record = dbfind( $db, "sta == \\"PFO\\"" ) ;
$db[3] = $record;

.fi
.in
.ft R
.IP "\fBdbaddv\fP ( $db, field_name, value, [field_name, value, ...] )"
Add a new record with the specified values to the database.
New records are checked to insure the keys are filled out and don't
conflict with other records in the table.
If the id key in a defining table (orid in the origin table, for example)
is not specified, a new id is automatically generated, using dbnextid.
.ft CW
.in 2c
.nf

.ne 6

$new = dbaddv( $dbevent, 'evid', 1,
            'evname', 'fake',
            'prefor', 1,
            'auth', 'danq' ) ;

.fi
.in
.ft R
.IP "\fBdbaddnull\fP ( $db )"
Add a null record to the specified table, returning the record number 
of the added row.
.ft CW
.in 2c
.nf
.ne 3

$recno =  dbaddnull( $db );

.fi
.in
.ft R
.IP "\fBdbputv\fP ( $db, field_name, value, [field_name, value, ...] )"
Change the fields for an existing record to the specified values.
.ft CW
.in 2c
.nf

.ne 6

dbputv( $dbevent, 'evid', 1,
                  'evname', 'fake',
                  'prefor', 1,
                  'auth', 'danq' ) ;

.fi
.in
.ft R
.IP "\fBdbadd\fP ( $db [, record] )"
Add a record from the scratch record, or from the specified string
.ft CW
.in 2c
.nf

$recno = dbadd( $db ) ;

.fi
.in
.ft R
.IP "\fBdbnojoin\fP ( $db1, $db2, [join-keys] )"
returns a new view with all rows of db1 that don't join to db2, using the join-keys 
if specified
.ft CW
.in 2c
.nf

$db = dbnojoin ( $dborigin, $dbassoc ) ;

.fi
.in
.ft R
.IP "\fBdbjoin\fP ( $db1, $db2, [join-keys] )"
returns a new view which joins the two input views, using the join-keys 
if specified
.ft CW
.in 2c
.nf

$db = dbjoin ( $dborigin, $dbassoc ) ;

.fi
.in
.ft R
.IP "\fBdbtheta\fP ( $db1, $db2, [expression] )"
returns a new view with all combinations of rows, limited to those satisfying
expression if specified
.ft CW
.in 2c
.nf

$db = dbtheta ( $dborigin, $dbsite ) ;

.fi
.in
.ft R
.IP "\fBdbsubset\fP ( $db, expression )"
returns a new view which is the set of all row which satisfy the expression
.ft CW
.in 2c
.nf

$dbsubsetted = dbsubset ( $dbwfdisc, 'sta=="AAK"' ) ;

.fi
.in
.ft R
.IP "\fBdbseparate\fP ( $db, table )"
return a new view which consists of all the rows of the specified table 
which participate in the joined view $db
.ft CW
.in 2c
.nf

$dboriginsubset = dbseparate ( $db, 'origin' ) ;

.fi
.in
.ft R
.IP "\fBdbsever\fP ( $db, table )"
return a new view which consists of all the unique rows left 
after removing the specified table from the input view
.ft CW
.in 2c
.nf

$dbwithoutorigin = dbsever ( $db, 'origin' ) ;

.fi
.in
.ft R
.IP "\fBdbunjoin\fP ( $db, database )"
create a new database, containing all the records referenced 
in the input view
.ft CW
.in 2c
.nf

dbunjoin ( $db, '/tmp/testdb' ) ;

.fi
.in
.ft R
.IP "\fBdbprocess\fP ( $db, cmd1, cmd2, cmd3 ... )"
returns a new view which is the result of applying the dbprocess
commands cmd1, cmd2, etc to the input database pointer.
.ft CW
.in 2c
.nf

$dbprocess = dbprocess ( $db, 'dbopen wfdisc',
                              'dbjoin site',
                              'dbsubset distance(38,-104,lat,lon)<15') ;

.fi
.in
.ft R
.IP "\fBdbquery\fP ( $db, code )"
Query the database for information. The standard Datascope codes must
be in quotes.
.ft CW
.in 2c
.nf

.ne 6

$nrecords =  dbquery( $db, 'dbRECORD_COUNT' ) ;
$description = dbquery( $db, 'dbTABLE_DESCRIPTION' ) ;
$detail = dbquery( $db, 'dbTABLE_DETAIL' ) ;
$ntables = dbquery( $db, 'dbTABLE_COUNT' ) ;

.fi
.in
.ft R
.IP "\fBdbnrecs\fP ( $db )"
Return the number of records in a table or view. This function is
shorthand for dbquery( $db, 'dbRECORD_COUNT' );
.ft CW
.in 2c
.nf
.ne 3

$nrecords =  dbnrecs( $db );

.fi
.in
.ft R
.IP "\fBds_dbclose\fP ( $db )"
Close a Datascope database
.ft CW
.in 2c
.nf

ds_dbclose ( $db );

.fi
.in
.ft R
.IP "\fBdbfree\fP ( $db )"
Free Datascope memory
.ft CW
.in 2c
.nf

dbfree ( $db );

.fi
.in
.ft R
.IP "\fBdbdestroy\fP ( $db )"
Destroy all tables of a Datascope database
.ft CW
.in 2c
.nf

dbdestroy ( $db );

.fi
.in
.ft R
.IP "\fBdbtruncate\fP ( $db, $nrecords )"
Truncate a database table to the specified number of records
.ft CW
.in 2c
.nf

dbtruncate ( $db, $nrecords ) ;

.fi
.in
.ft R
.IP "\fBdbresponse\fP ( $filename )"
Returns a PHP resource for a response object, representing the 
instrument response curve defined in $filename. This resource 
may be subsequently queried with \fBeval_response\fP.
.ft CW
.in 2c
.nf

$response = dbresponse( $filename ) ;

.fi
.in
.ft R
.IP "\fBeval_response\fP ( $response, $omega )"
Evaluates a response object at the specified angular frequency, 
returning the real and imaginary components of the response
.ft CW
.in 2c
.nf

$pi = 3.1415;
$f_hz = 5; 

$cx = eval_response( $response, 2 * $pi * $f_hz );

$real = $cx[0];
$imag = $cx[1];

.fi
.in
.ft R

.IP "\fBstrtdelta\fP ( $epoch )"
Convert an elapsed time in seconds to a string representation
.ft CW
.in 2c
.nf

$elapsed = strtdelta ( $epoch );

.fi
.in
.ft R

.IP "\fBstrtime\fP ( $epoch )"
Convert an epoch time in seconds to a string representation
.ft CW
.in 2c
.nf

$astring = strtime ( $epoch );

.fi
.in
.ft R

.IP "\fBstrydtime\fP ( $epoch )"
Convert an epoch time in seconds to a string representation
.ft CW
.in 2c
.nf

$astring = strydtime ( $epoch );

.fi
.in
.ft R

.IP "\fBstrdate\fP ( $epoch )"
Convert an epoch time in seconds to a string representation
.ft CW
.in 2c
.nf

$astring = strdate ( $epoch );

.fi
.in
.ft R

.IP "\fBstrlocaltime\fP ( $epoch )"
Convert an epoch time in seconds to a string representation
.ft CW
.in 2c
.nf

$astring = strlocaltime ( $epoch );

.fi
.in
.ft R

.IP "\fBstrlocalydtime\fP ( $epoch )"
Convert an epoch time in seconds to a string representation
.ft CW
.in 2c
.nf

$astring = strlocalydtime ( $epoch );

.fi
.in
.ft R

.IP "\fBstrlocaldate\fP ( $epoch )"
Convert an epoch time in seconds to a string representation
.ft CW
.in 2c
.nf

$astring = strlocaldate ( $epoch );

.fi
.in
.ft R

.IP "\fBdbwrite_view\fP ( $db, $filename )"
Save a database view to a file
.ft CW
.in 2c
.nf

	$db = ds_dbopen( "testdb", "r" );

	$db = dblookup( $db, "", "origin", "", "" );

	$db = dbprocess( $db, "dbsubset ml > 3" );

	dbwrite_view( $db, "testdb.precious" );

.fi
.in
.ft R

.IP "\fBdbread_view\fP ( $filename [, $viewname] )"
Read a database view from the given filename, optionally specifying the name for the view
.ft CW
.in 2c
.nf

	$db = dbread_view( "testdb.precious" );

.fi
.in
.ft R

.IP "\fBdbsave_view\fP ( $db )"
Save a database view as part of the database
.ft CW
.in 2c
.nf

	$db = ds_dbopen( "testdb", "r" );

	$db = dblookup( $db, "", "origin", "", "" );

	$db = dbprocess( $db, "dbsubset ml > 3" );

	dbsave_view( $db );

.fi
.in
.ft R

.IP "\fBdbdelete\fP ( $db )"
Delete a row from a database table
.ft CW
.in 2c
.nf

	$db = ds_dbopen( "testdb", "r" );

	$db = dblookup( $db, "", "origin", "orid", "645" );

	dbdelete( $db );

.fi
.in
.ft R

.IP "\fBdbmark\fP ( $db )"
Mark a row of a database table for deletion (set all fields to null)
.ft CW
.in 2c
.nf

	$db = ds_dbopen( "testdb", "r" );

	$db = dblookup( $db, "", "origin", "orid", "645" );

	dbmark( $db );

.fi
.in
.ft R

.IP "\fBdbcrunch\fP ( $db )"
Remove null (marked) rows from a database table
.ft CW
.in 2c
.nf

	$db = ds_dbopen( "testdb", "r" );

	$db = dblookup( $db, "", "origin", "orid", "645" );

	dbmark( $db );

	dbcrunch( $db );

.fi
.in
.ft R

.SH EXAMPLE
.ft CW
.in 2c
.nf

.ne 16

#!/bin/sh
exec /usr/local/bin/php -f $0

<?php
if(!extension_loaded('Datascope')) {
        dl('Datascope.so');
}
$module = 'Datascope';
$functions = get_extension_funcs($module);
echo "Functions available in the test extension:<br>\\n";
foreach($functions as $func) {
    echo $func."<br>\\n";
}
echo "<br>\\n";

.ne 6
$mydb =ds_dbopen( "/opt/antelope/data/db/demo/demo", "r" );

$mydb = dbprocess( $mydb, "dbopen origin",
                          "dbsubset ml > 3" );
echo "table has ", dbnrecs( $mydb ),
     " records after subset\\n";

.ne 5
$mydb[3] = 0;
list( $lat, $lon, $ndef, $auth, $lddate ) =
    dbgetv( $mydb, "lat", "lon", "ndef", "auth", "lddate" );

echo "$lat, $lon, $ndef, $auth, $lddate\\n";

.ne 6
$moo = dbex_eval( $mydb, "lat + lon" );

echo var_dump( $moo ), "\\n";

$moo = dbquery( $mydb, "dbVIEW_TABLES" );
echo var_dump( $moo ), "\\n";

?>

.fi
.in
.ft R
.SH LIBRARY
.SH "SEE ALSO"
.nf
perldb(3P)
.fi
.SH "BUGS AND CAVEATS"

WARNING: This is an unfinished prototype!!

.SH AUTHOR
.nf
Kent Lindquist
Lindquist Consulting
.fi
.\" $Id$
