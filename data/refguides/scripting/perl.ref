<chapter Perl Interface>
<body>
% man perldb
<function>
use Datascope ; 

<subsection Opening a database>
<function>

dbopen ( database, permissions )
    returns a database pointer to the database

dbopen_database ( database, permissions )
    open database (or database.table or "-" for view from stdin), returning database pointer

dbopen_table ( database.table, permissions )
    open database.table (or "-" for view from stdin), returning database pointer for a table


dbclose ( @db )
    closes the database, freeing all resources used by it

dbfree ( @db )
    frees resources for a table or a database


dblookup ( @db, database, table, field, row )
    returns a database pointer for the specified database, table, field, and row.

dbfind ( @db, expression [, first [,reverse]])
    find first row matching expression, starting with first; if reverse, search backwards 

<subsection Manipulating fields and records>
dbadd ( @db [, record] )
    add the new record to the table in @db. If record is not specified, add the scratch record. returns the new row number, or an error code < 0.

dbaddnull ( @db )
    add a new null row to a table

dbaddv ( @db, field_name, value, [field_name, value, ...] )
    add a new row with the specified values to the database


dbmark ( @db )
    set the specified rows to all null values

dbdelete ( @db )
    delete a row from the database

dbcrunch ( @db )
    delete all marked (null) rows from the specified table

dbtruncate ( @db, n )
    truncate a table to the specified number of rows

dbdestroy ( @db )
    delete all tables and the descriptor file for the specified database, but not external files


dbget ( @db [, 0] )
    returns [or copies to the scratch rows] the specified field or rows 

dbgetv ( @db, field_name [, field_name, ...] )
    returns the values of the specified fields for a particular rows


dbput ( @db [, string] )
    copies from string (or from the scratch rows) to the specified field or rows

dbputv ( @db, field_name, value [, field_name, value, ...] )
    save the specified values into the specified fields for a particular rows


dbadd_remark ( @db, remark )
    add a comment in the remark table for the specified table/rows

dbget_remark ( @db )
    get any comment from the remark table for the specified table/rows


<subsection Forming views>
dbgroup ( @db, key [, key, ...] )
    group the input table according to the specified keys

dbjoin ( @db1, @db2[, join-keys] )
    return a join of the two tables, using the join-keys if specified

dbmatches ( @db1, @db2, hookname [, join-keys] )
    returns a list of the rows in db2 which match the rows specified by db1

dbnojoin ( db1, db2[, join-keys] )
    returns a view of all rows in the first table which don't join to the second.

dbprocess ( @db, commands )
    returns a new view which is the result of applying the dbprocess
    commands to the input view; possible operations are: dbopen,
    dbjoin, dbgroup, dbleftjoin, dbnojoin, dbselect, dbseparate,
    dbsever, dbsort, dbsubset, dbtheta, dbungroup

dbsort ( @db [, -u][, -r][, key, key..] )
    sort the input table according to the specified keys, uniquely if -u, 
    in reverse order if -r 

dbsubset ( @db, expression )
    returns a new view which is the set of all rows which satisfy the expression

dbtheta ( @db1, @db2, [expression] )
    returns new join view with all combinations of rows from the two tables which 
    satisfy expression, or all combinations if no expression is specified

dbunjoin ( @db, database )
    create a new database, containing all the records referenced in the input view @db


dbsave_view ( @db, name )
    save the view into a file named database.name

<subsection Miscellaneous Datascope Functions>
dbquery ( @db, code )
    query the database for information, eg dbquery(@db, "dbRECORD_COUNT").  see 
    Datascope Constants

dbex_eval ( @db, expression )
    evaluate expression for a particular row

dbcompile ( @db, string )
    add new attributes or relations to the schema directly from the perl script

dbextfile ( @db [, base-table] )
    return the filename for an external file for a particular row in a view

dbnextid ( @db, id_name )
    gets the next free id value for the specified database and id_name

<subsection Error handling>
elog_init ( $0, @ARGV )
    initialize the elog message routines

elog_log ( msg )
    save a message on the elog message log

elog_debug ( msg )
    send a debug message to the elog facility

elog_notify ( msg )
    send a notify message to the elog facility

elog_alert ( msg )
    send a alert message to the elog facility

elog_complain ( msg )
    send an error message to the elog message facility 

elog_die ( msg )
    send a message to the elog message facility and die


elog_clear ( )
    clear the elog message log


elog_mark ( )
    return the count of messages currently held in the error log

elog_flush ( deliver, first )
    eliminate log messages after first, printing them if deliver is set

<subsection Parameter files>
pfget ( pfname, key )
    extracts the value for the key from the parameter file pfname

pfupdate ( pfname )
    checks and rereads a parameter file if one of the components along PFPATH has changed

<subsection Special functions>
ask ( string )
    pose a question string at the controlling tty, and return the response

askyn ( string )
    pose a yes/no question string at the controlling tty, and return 
    0=false, 1=true

askynaq ( string )
    pose a yes/no question string at the controlling tty, and return 
    0=false, 1=true, 2=all, 3=quit

datafile ( env, file )
    find the specified file by looking at first the environment variable, and then along the path

datapath ( env, dir, file, suffix )
    find the specified file by looking at first the environment variable, and then along the path

makedir(d)
    make the complete directory path d (like "mkdir -p") 

abspath (a)
    returns the absolute path to the specified file a.

relpath (f, t)
    returns a relative path from f to t. f must be a directory.

cleanpath (p [, nolinks])
    normalize the input path p, removing extra "..", "//", and
    "./"  strings.   With a  second  argument,
    resolve any symbolic links along the path.

concatpaths (a,b)
    concatenate the two paths a and b  properly,  adding  a
    slash if necessary.

parsepath (a)
    returns directory, file basename, and suffix for path a.


grn ( lat, lon )
    return the geographic region number

grname ( lat, lon )
    return the geopgraphic region name

srn ( lat, lon )
    return the seismic region number

srname ( lat, lon )
    return the seismic region name


limit ( resource, [limit2set] )
    return the current resource limit, or set a new resource limit; possible
    resources are:
<example>
cputime      filesize     datasize     
stacksize    coredumpsize vmemoryuse   
</options>

<subsection Time conversion>

epoch2str ( epoch, fmt [, timezone] )
    returns the epoch time formatted according to the fmt string and converted to timezone

str2epoch ( string )
    returns the epoch time corresponding to the free-form input time/date


strtime ( epoch )
    returns epoch time formatted like "4/23/2001  15:35:15.000"

strydtime ( epoch )
    returns epoch time formattted like "4/23/2001 (113) 15:35:15.000"

strdate ( epoch )
    convert epoch time to a date, eg "4/23/2001"

strtdelta ( dt )
    convert the time-difference dt (in seconds) to a string, eg "30:35 minutes"


epoch ( yearday )
    returns the epoch time corresponding to the integer yearday

yearday ( epoch )
    returns the yearday corresponding to an epoch time
