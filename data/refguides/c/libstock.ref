<library>
General Utilities
stock
-lposix4 -lnsl -lsocket -lm
STOCKLIBS
stock.h
implements various general purpose
programming utilities

<subsection Miscellaneous>
<cdeclarations>

private void banner ( char *program, char *version )
    print header with program name, version, BRTT address

void cbanner ( char *version, char *usage, char *author, char *location, char *email )
    print header with program name, version, and author contact information

void *usermethod ( char *method )
    returns pointer to routine method from libuser.so (0 if not found) 

int verbose_exists ()
    return 1 if file "verbose" exists, 0 otherwise

<subsection Compression>
int gencompress ( uchar **out, int *nout, int *szout, int *in, int n, int len )
    compress n input integers in, using run length len, returning result as
    *nout bytes in *out. 

int genuncompress ( int **out, int *nout, int *size, unsigned char *in, int n )
    uncompress the n bytes buffer in, returning result as *nout integers in *out.

<subsection Environment>
int envfile ( char *filename )
    set the environment according to the key, value list from $ANTELOPE/data/env/filename

int fixup_env ( char **list, int n, int force )
    set the environment using the n key,value pairs of list;
    if force is 0, only unset environment variables are set

private char *getantelope ( )
    return the ANTELOPE root directory

void unsetenv ( char *name )
    eliminate the environment variable name

<subsection Data file references>
char *datafile ( char *env, char *file)
    return path of filename file under $ANTELOPE/data, possibly overridden with environment variable env

char *datapath ( char *env, char *dir, char *file, char *sfx )
    return path of filename file (with suffix sfx) in directory dir under $ANTELOPE/data, possibly overridden with environment variable env

int newdata ( char *path, char *env, char *dir, char *file, char *sfx )
    return complete path for file (with suffix sfx) in directory dir under $ANTELOPE/data, 
    allowing environment variable env to override

Tbl *datasearch(char *search, char *dir, char *file, int flags)
    returns list of all paths matching dir/file along the path search. If (flags & 1), $name in paths is expanded; if (flags & 2), all possible paths are returned.

deprecated int mappath ( char *spath, char *upath )
    translate pathnames (formerly used for remapping automount paths)

deprecated void setmapcf ( char *fn )
    set the name of the configuration file for mappath

<subsection State Files>
int bury ( )
    save state file, as specified by calls to resurrect and resurrect

int exhume ( char *nm, int *stop, int sec, void (*f)() )
    recover state file nm, and set up to save new copy.  sets up interrupt
    handlers which set stop to cause the application to quit.  If timer
    expires sec seconds after interrupt, calls the routine f, then 
    bury, and then exits.

int resurrect ( char *name, void *value, int type )
    recover old value for name from state file, set up to save on later
    calls to bury.  type is INT_RELIC, DOUBLE_RELIC or STRING_RELIC

<subsection Associative Arrays>
Arr *newarr ( int (*cmp)() )
    create a new associative array with string compare routine cmp

int freearr ( Arr *root, void (*free_value) () )
    free an associative array, calling free_value on each value of the array

void *setarr ( Arr *arr, char *key, void *value )
    set the key element of associative array arr to the pointer value

void *getarr ( Arr *arr, char *key )
    return the value pointer for element key of associative array arr 

void *delarr ( Arr *arr, char *key )
    delete the key, value pair from associative array arr, returning the value pointer

int cntarr ( Arr *arr )
    return the number of key, value pairs in associative array arr

Tbl *keysarr ( Arr *arr )
    get a list of all the keys of associative array arr

Tbl *valsarr ( Arr *arr )
    get a list of all the values of associative array arr

int applyarr ( Arr *arr, void (*f) (char *key, void *value, void *p), void *p)
    apply function f to each key, value pair of associative array arr

Tbl *arrgrep ( Arr *arr, char *s )
    match each key of array arr as a regular expression against string s, returning a list of all keys which match

Tbl *greparr ( char *re, Arr *arr )
    match regular expression re to each key of array arr, returning a list of all keys which match

<subsection Bit Vectors>

Bitvector *bitnew ( )
    create a new bit vector

void bitfree ( Bitvector *b )
    free a bit vector


int bitclr ( Bitvector *b, int index )
    clear bit index of bit vector b

int bitset ( Bitvector *b, int index )
    set bit index of bit vector b

int bittst ( Bitvector *b, int index )
    test bit index of bit vector b


int bitmax ( Bitvector *b )
    return current allocated size of b


Bitvector *bitnot ( Bitvector *b )
    return the bitwise NOT of b

Bitvector *bitand ( Bitvector *b1, Bitvector *b2 )
    return the bitwise AND of b1 and b2

Bitvector *bitor ( Bitvector *b1, Bitvector *b2 )
    return the bitwise OR of b1 and b2

Bitvector *bitxor ( Bitvector *b1, Bitvector *b2 )
    return the bitwise eXclusive-OR of b1 and b2

int bitcmp ( Bitvector *b1, Bitvector *b2 )
    compare two bit vectors

<subsection Simple Ring Buffer>

RingBuffer *openring(char *filename, char *id, int depth, int flags)
    open (or create) a simple ring buffer in filename with size depth

int newring(char *filename, char *id, int depth, int flags)
    create (or reinitialize) a simple ring buffer in filename with size depth

void closering(RingBuffer *rb)
    close the ring buffer rb

void pushring(RingBuffer *rb, double time, double value)
    push a time/value pair onto the ring buffer rb

int getring(RingBuffer *rb, int i, double *time, double *value)
    get the i'th time/value pair from the ring buffer rb

int countring(RingBuffer *rb)
    return the number of pairs in the ring buffer

double maxring(RingBuffer *rb, double tdelta, int *index)
    return the maximum value within tdelta from the ring buffer rb

double minring(RingBuffer *rb, double tdelta, int *index)
    return the minimum value within tdelta from the ring buffer rb

double avgring(RingBuffer *rb, double tdelta)
    return the average value over tdelta from the ring buffer rb

int findring(RingBuffer *rb, double value, double tdelta)
    find the index of ring buffer entry which has the specified value within tdelta entries

int changedring ( RingBuffer *rb, double tdelta );
    return 1 if the value has changed over the period tdelta

<subsection Buffered Network Stream I/O>

Bns *bnsnew ( int fd, int sz )
    create a new network stream I/O buffer

void bnsfree ( Bns *bns )
    free space associated for bns

int bnsclose ( Bns *bns )
    close file descriptor and free space for bns


void bnsuse_sockio ( Bns *bns )
    setup bns to use socket routines rather than read and write


int bnsget ( Bns *bns, void *data, int t, int n )
    get n elements of type t from bns, returning the result in data

int bnsput ( Bns *bns, void *data, int t, int n )
    put n elements of type t from data, into buffer of bns 

int bnsflush ( Bns *bns )
    write all data currently in bns buffer


void bnsmark ( Bns *bns )
    save the current read point in the input buffer; don't allow any
    data after this mark to be lost from buffer

void bnsrestore ( Bns *bns )
    back up in input pointer to previous mark 

void bnsrelease ( Bns *bns )
    reset mark on the input buffer


void bnsclr ( Bns *bns )
    wipe clean the bns buffer

int bnscnt ( Bns *bns )
    return count of characters in bns buffer

int bnseof ( Bns *bns )
    return non-zero when end of file occurs on input

int bnserr ( Bns *bns )
    return non-zero after an error occurs on a bns

int bnserrno ( Bns *bns )
    returns any system errno recorded by bns after read or write


int bns2buf ( Bns *bns, char *buf, int maxbuf )
    copy bns buffered data elsewhere

int buf2bns ( Bns *bns, char *buf, int nbytes )
    put data directly into a bns buffer


int bnstimeout ( Bns *bns, int milliseconds )
    set the bns timeout period


int bnswait ( Bns *bns )
    wait until the bns timeout for data to appear


int gbnsSync ( Bns *bns, char *sync, int nsync, int stric )
    synchronize an input stream to a character sequence

int pbnsSync ( Bns *bns, char *sync, int nsync )
    synchronize an output stream to a character sequence

<subsection Error handling>
int elog_init ( int argc, char **argv )
    initialize elog routines

private void clear_register ( int deliver )
    clears the error register, printing the contents if asked

private void register_error ( int flag, char *format, ... )
void elog_log ( int flag, char *format, ... )
    add a message to the internally accumulating error log

void elog_debug ( int flag, char *format, ... )
    deliver a message and return

void elog_notify ( int flag, char *format, ... )
    deliver a message and return

void elog_alert ( int flag, char *format, ... )
    deliver a message and return

private void complain ( int flag, char *format, ... )
void elog_complain ( int flag, char *format, ... )
    deliver a message and return

private void die ( int flag, char *format, ... )
void elog_die ( int flag, char *format, ... )
    deliver a message and exit with error code 1

void elog_fault ( int flag, char *format, ... )
    report a hardware error and exit with error code 1

char *elog_string ( int first )
    returns freshly allocated string reproducing the entire error log 

void elog_clear ()
    clear the log of error messages

int elog_mark ()
    return the number of messages in the error log

void elog_flush ( int deliver, int first )
    flush elog messages from first, printing them if deliver is non-zero

void elog_print ( FILE *file, int first )
    print the error log from first to the end

void elog_free_msg ( void *vmsg )
    free an elog message

void elog_msg_print ( FILE *file, Elog_msg *elog_msg )
    print an elog message

int elog_query ( enum Elog_code code, int severity, void **value )
    retrieve various parameters from elog interface

int elog_set ( enum Elog_code code, int severity, void *value )
    set various parameters for elog interface

<subsection General Programming Utilities>

Hook *new_hook ( void (*hookfree)() )
    create a standard structure which contains a pointer to a free routine and
    a (void *) pointer

void free_hook ( void **hookp )
    free a hook structure, first calling the hookfree routine to free the private pointer, and then freeing the structure


int runcmd ( char **argv, char **result )
    execute a command, returning a result and the exit code

void compress ( char *path )
    compress files in background


deprecated Signal_info *signal_byname ( char *name )
    translate a signal name into description

deprecated Signal_info *signal_bysig ( int sig )
    translate a signal code into name and description


void wait_for_time ( double time, int verbose )
    sleep until a specified epoch time


int xlatname ( char *name, Xlat *xlat, int nxlat )
    lookup a name in a static translation table

char *xlatnum ( int num, Xlat *xlat, int nxlat )
    look up a number in a static translation table



int clr_fl ( int fd, int flags )
    clear file status flags

int set_fl ( int fd, int flags )
    set file status flags


void fill_random ( char *buffer, int nbytes, int *position )
    fill a buffer with random values

int check_random ( char *buffer, int nbytes )
    compare a buffer previously filled with fill_random
    with the values expected.

int set_random ( int nbytes )
    set the size of the check_random internal buffer

double disordered()
    pseudo random number

<subsection Filename and Path manipulation>
int abspath ( char *relp, char *absp )
    return an absolute path absp from the relative path relp

int relpath ( char *fromdir, char *tofile, char *relp )
    return a relative path relp from fromdir to tofile

int cleanpath ( char *path, int flags, char *new )
    remove any unnecessary '/', '..', and '.' strings from path returning the result
    in new; if flags is 1, any intermediate symbolic links are resolved and removed.

char *concatpaths ( char *seg1, *seg2, ... 0 )
    concatenate the path segments seg1, seg2, ... and
    return the result.

int fspath ( char *path, char *host, char *filesystem )
    return the host and filesystem corresponding to the path

InfoPath * infopath ( char *path )
    return additional information about path including
    disk space and inodes available

char *homedir(char *user)
    return the home directory of the specified user.

int is_file(char *path)
    returns 1 if path is plain file, 0 otherwise

int is_nfs(char *path)
    returns 1 if path is nfs mounted, 0 otherwise

void parsepath ( char *path, char *dir, char *base, char *suffix )
    separate a path into a directory dir and a basename base with
    an option suffix


deprecated char **antelope_glob ( char *globpattern )
    shell glob routine

void dirbase ( char *path, char *dir, char *base )
    separate a path into directory and basename components



private int gethdir ( char *user, char *home )
    get home directory of user

int makedir ( char *dir )
    ensure that a directory exists


int mapfile ( char *filename, Arr **maparr, char **mmap_datap )
    map a file into memory if necessary

int unmapfile ( char *filename, Arr **maparr )
    unmap the specified filename from memory

int unmaparr ( Arr **maparr )
    unmap all mapped files

int mkfile ( char *name, unsigned long nbytes, char *init, int initsize)
    make a file name nbytes nbytes long with the first initsize bytes initialized with the buffer init

FILE *gz_cat ( char *filename, char *permissions )
    returns a FILE open to the output of zcat

FILE *gz_open ( char *filename, char *permissions )
    alternate interface to zopen

FILE *zopen ( char *filename, char *permissions )
    fopen a compressed or uncompressed file

<subsection Strings>
int blank ( char *s )
    return non-zero if string is entirely blank characters

int whitespace ( char *s )
    returns non-zero if string is entirely whitespace

void copystrip ( char *dest, char *source, int n )
    copy a string, stripping leading and trailing blanks

private int cs2fs ( char *dst, char *src, int nmax )
    cast a C string for Fortran

private int fs2cs ( char *dst, char *src, int nmax )
    cast a fortran string to C format

private char *newcs ( char *fs, int n )
    copy a fortran string into a newly allocated buffer

char *expand_env ( char *s )
    substitute environment variables into string

void strtrim ( char *s )
    trim leading and trailing whitespace characters from string s

void str2lower ( char *s )
void str2upper ( char *s )
    convert string s to all lower/upper case

void strsub ( char *old, char *s, char *sub, char *r )
    replace occurences of string s in old with sub, leaving result in r

int patsub ( char *old, regex_t *pat, char *sub, char *r )
    replace occurence of regular expression pat in string old with sub, leaving result in r

int strmatches ( char *s, char *pattern, Hook **hook );
    returns 1 if entire string s matches the regular expression pattern

int strcontains ( char *s, char *pattern, Hook **hook, int *start, int *nchars );
    returns 1 if string s contains the regular expression pattern; the
    start of the first occurrence and number of matching characters nchars are returned.

void sncopy ( char *dest, char *source, int n )
    copy a string with max n characters, padding if necessary

Tbl *split ( char *string, char c )
    split a string into component pieces


private int strcpy_pad ( char *dst, int dstmax, char *src, int srcmax, char pad )
    copy a string, truncating or padding as necessary

void szcopy ( char *dest, char *source, int n )
    copy exacly n characters, then append null

void pushstr(void **sbuf, char *s)
    add the string s to the string buffer sbuf, creating sbuf if *sbuf == 0

char *popstr(void **sbuf, int sfree)
    retrieve the entire string from sbuf, freeing sbuf if sfree != 0

<subsection Sorting and Searching>
void isort ( char *a, int n, int size, int (*compare)(), void *pvt )
    insertion sort implementation

void quicksort ( char *a, int n, int size, int (*compare)(), void *pvt )
    quick sort implementation

void shellsort ( char *a, int n, int size, int (*compare)(), void *pvt )
    shell sort implementation

int ssearch ( char *key, int keysize, char *index, int nkeys, int unique, int (*compare)(), void *pvt, int *ns, int *ne )
    binary search of index

<subsection User Interaction>
char *ask ( char *format, ... )
    query user for a response

char *asknoecho ( char *format, ... )
    query user for a response with no echo

int askyn ( char *format, ... )
    query user for a yes/no response

int askynaq ( char *format, ... )
    query user for a yes/no/all/quit response

int yesno ( char *s )
    check string for various ways of meaning yes or no

int fdkey ( int fd )
    tests file descriptor for pending input

int fdwait ( int fd, int msec )
    wait up to msec milliseconds for pending input

<subsection Hexadecimal dumps>
void Hexdump ( FILE *file, int base, void *memory, int l )
    hex dump a memory buffer, with base added

void hexdump ( FILE *file, void *memory, int l )
    write a hex and ascii dump of a memory buffer

void read_hexdump ( FILE *file, char *memory, int l )
    read a hex dump back into memory


void asciidump ( FILE *file, char *memory, int l )
    write ascii dump of a buffer, with escaped non-printing chars

void read_asciidump ( FILE *file, char *memory, int l )
    read an ascii dump back into memory


int nomem ( char *memory, int n )
    true if memory address range is invalid


int hex2int ( char c )
    returns the integer value of a hexadecimal character

int printable ( char *memory, int l )
    tests bytes to see if they're printable

void printable_string ( char *buf, int n, char *memory, int l )
    copies bytes from memory into ascii-printable form

<subsection Byteswap routines>
void swap2 ( unsigned char *from, unsigned char *to, int n )
    swap two bytes

void swap4 ( unsigned char *from, unsigned char *to, int n )
    swap four bytes

void swap8 ( unsigned char *from, unsigned char *to, int n )
    swap eight bytes


int align_double ( int i )
    align an address to a multiple of double

int align_int ( int i )
    align an address to a multiple of int

void H2N2(char *to, char *from, int n)
void N2H2(char *to, char *from, int n)

void H2N4(char *to, char *from, int n)
void N2H4(char *to, char *from, int n)

void H2N8(char *to, char *from, int n)
void N2H8(char *to, char *from, int n)
    convert n 2 byte ints, 4 byte ints (or floats) or 8 byte
    ints (or doubles) from Host order to Network order, or vice versa

void H42N3 ( char *to, int *from, int n )
    convert n 3 byte signed integers from network order to 4 byte host order signed integers

void N32H4 ( int *to, char *from, int n )
    convert n 4 byte host order signed integers to 3 byte signed network order integers

void HD2NF ( char *to, double *from, int n )
    convert from host double to net float

void NF2HD ( double *to, char *from, int n )
    convert from network float to host double


void NF2HI ( int *to, char *from, int n )
    convert from net float to host int

void HI2NF ( char *to, int *from, int n )
    convert from host int to net float


void HI2NC ( char *to, int *from, int n )
    convert from host int to net character

void NC2HI ( int *to, char *from, int n )
    convert from net character to host int


void HI2NS ( char *to, int *from, int n )
    convert from host int to net short

void NS2HI ( int *to, char *from, int n )
    convert from net short to host int


private double htond ( double val )
    convert host double to net double

private void htondp ( double *valp_from, double *valp_to )
    convert pointer to host double to pointer to net double

private float htonf ( float val )
    convert host float to net float

private void htonfp ( float *valp_from, float *valp_to )
    convert pointer to host float to pointer to net float

deprecated int isnetorder ( )
    returns true if local machine uses network order

private double ntohd ( double val )
    convert net double to host double

private void ntohdp ( double *valp_from, double *valp_to )
    convert pointer to net double to pointer to host double

private float ntohf ( float val )
    convert net float to host float

private void ntohfp ( float *valp_from, float *valp_to )
    convert pointer to net float to pointer to host float

private int rev4 ( char *from, char *to, int n )
    reverse order of 4 bytes

private int rev8 ( char *from, char *to, int n )
    reverse order of 8 bytes

<subsection Lists>
Tbl *newtbl ( int size )
    initialize a new list (simple interface)

Tbl *inittbl ( int left_grow, int right_grow, int direct, char *null, int entry_size )
    initialize a new list, usually a direct list

void freetbl ( Tbl *tbl, void (*free_tblval) () )
    free memory used by a list


int maxtbl ( Tbl *tbl )
    count elements of a list

Tbl *duptbl(Tbl *old, void *(*dup_tblval)())
    duplicates (clones) the old Tbl using the dup_tblval routine to duplicate individual elements.

void clrtbl ( Tbl *tbl, void (*free_tblval) () )
    empty an existing list

void trunctbl ( Tbl *tbl, int last, void (*free_tblval) () )
    shorten a list to the specified number of elements



int settbl ( Tbl *tbl, int index, char *value )
    set a list element's value

char *gettbl ( Tbl *tbl, int index )
    get a list element's value


int instbl ( Tbl *tbl, int index, char *value )
    insert an element into a list

char *deltbl ( Tbl *tbl, int index )
    delete an element from a list


char *poptbl ( Tbl *tbl )
    remove and retrieve an entry from the end of a list

int pushtbl ( Tbl *tbl, char *value )
    append an entry to the end of a list


char *shifttbl ( Tbl *tbl )
    remove and retrieve an entry from the beginning of a list

int unshifttbl ( Tbl *tbl, char *value )
    prepend an entry to the beginning of a list



int filetbl ( char *filename, char *id, int size, void *null, int entry_size, Tbl **ptbl )
    read or create a list on disk

Tbl *readtbl ( char *filename, char **id, int rw )
    read a list from disk

int savetbl ( Tbl *tbl, char *filename, char *id )
    write a list to disk


Tbl *greptbl ( char *re, Tbl *tbl )
    search a list with a regular expression

Tbl *tblgrep ( Tbl *tbl, char *string )
    match a string to list of regular expressions


void sorttbl ( Tbl *tbl, int (*compare) (), void *pvt )
    sort a list given an element comparison function compare

int searchtbl ( char *key, Tbl *tbl, int (*compare) (), void *pvt, int *ns, int *ne )
    search a sorted list using a binary search


int applytbl ( Tbl *tbl, int (*function) (), void *pvt )
    apply a function to all elements of a list


Tbl *strtbl ( char *s1, ...)
    create a Tbl list from a list of strings

char *jointbl ( Tbl *tbl, char *s )
    return a string containing all elements of a list


int cattbl ( Tbl *tbldest, Tbl *tblsrc )
    copy one list to another

int cmptbl ( Tbl *tbl1, Tbl *tbl2 )
    compare two lists


int newmorphtbl ( Tbl *list, Morphtbl **map )
    create a new Morphtbl: a list of patterns and substitutions

int morphtbl ( char *old, Morphtbl *map, int flags, char *r )
    apply the patterns and substitutions in map to the old string, leaving
    the result in r. flags is composed of MORPH_PARTIAL and MORPH_ALL.
    if MORPH_PARTIAL is set, the pattern need not match the entire land.
    if MORPH_ALL is set, all the patterns are applied; otherwise just the
    first matching pattern is used.

void freemorphtbl ( Morphtbl *map )
    free up a Morphtbl

<subsection Compression and Checksums>
int ccanada ( int *data, int nsamp, char **compressedp, int *nbytes, int *compressedsz )
    data compression using the Canadian Compression Scheme

int ucanada ( char *compressed, int nbytes, int **datap, int *nsamp, int *datasz )
    data uncompression using the Canadian Compression Scheme


int cm6 ( int *data, int nsamp, char **encoded, int *nbytes, int *encodedsz )
    compress GSE AutoDRM CM6 format

int um6 ( char *encoded, int nbytes, int **data, int *nsamp, int *datasz )
    uncompress GSE AutoDRM CM6 format


int gse_checksum ( int *signal, int nsamp )
    compute gse checksum for AutoDRM


int cucsd ( int *data, int nsamp, char **buf, int *nbytes, int *bufsiz )
    compress data as in modified Reftek dataloggers

int uucsd ( int *data, char **bufp, int bufcnt, int nsamp )
    uncompress data from modified Reftek dataloggers

<subsection Parameter Files>
int pfread ( char *name, Pf **pf )
    read a parameter space

int pfin ( FILE *file, Pf **pf )
    read a parameter space from an open file

int pfload ( char *env, char *dir, char *file, Pf **pf )
    load a single parameter file, as found by datapath(3)

int pfupdate ( char *name, Pf **pf )
    update a parameter space

Tbl *pffiles ( char *name, int all )
    return a list of parameter files examined


int pfcompile ( char *s, Pf **pf )
    read a parameter space from a string

int pfout ( FILE *file, Pf *pf )
    write the parameter space pf to file

char *pf2string ( Pf *pf )
    convert a parameter space pf to a string


void pffree ( Pf *pf )
    free resources for a parameter space


int pfconfig ( char *name, void *value )
    override default settings such as the &ask routine

Tbl *pfkeys ( Pf *array )
    returns the list of keys from a parameter space array


Pf *pfnew ( int type )
    start a new parameter space

int pfout ( FILE *file, Pf *pf )
    write a parameter space to the specified file

int pfwrite ( char *filename, Pf *pf )
    write a parameter file space to the specified file


int pfget ( Pf *pf, char *name, void **result )
    get a value from a parameter space

int pfresolve ( Pf *pf, char *name, int create, Pf **value_pf )
    get a parameter from a parameter space allowing extended syntax to specify members of arrays or lists. (extended syntax allows expressions like arr{name}[3]).

int pfeval ( Pf *pf, char *name, char **value )
    get a parameter from a parameter space allowing extended syntax to specify members of arrays or lists, returning only scalar values (extended syntax allows expressions like arr{name}[3]).

Arr *pfget_arr ( Pf *pf, char *name )
    get an array value from a parameter space

int pfget_boolean ( Pf *pf, char *name )
    get a boolean value from a parameter space

double pfget_double ( Pf *pf, char *name )
    get a double precision value from a parameter space

int pfget_int ( Pf *pf, char *name )
    get an integer value from a parameter space

char *pfget_string ( Pf *pf, char *name )
    get a string value from a parameter space

Tbl *pfget_tbl ( Pf *pf, char *name )
    get a list value from a parameter space

int pfmaxtbl ( Pf *list )
    get the number of elements in the parameter space list

void pfput ( Pf *pf, char *name, char *value, int type )
    put a value into a parameter space

int pfset ( Pf *pf, char *name, char *value )
    put a parameter into a parameter space using perl style nested array indexing

void pfput_arr ( Pf *pf, char *name, Arr *value )
    put an array value into a parameter space

void pfput_boolean ( Pf *pf, char *name, int val )
    put a boolean value into a parameter space

void pfput_double ( Pf *pf, char *name, double val )
    put a double precision value into a parameter space

void pfput_int ( Pf *pf, char *name, int val )
    put an integer value into a parameter space

void pfput_string ( Pf *pf, char *name, char *value )
    put a string value into a parameter space

void pfput_tbl ( Pf *pf, char *name, Tbl *value )
    put a list value into a parameter space


int pfcmp(Pf *pf1, Pf *pf2)
    returns 0 if pf1 and pf2 are identical, 1 otherwise

<subsection Sorted Lists>
Stbl *newstbl ( int (*cmp)(Stbl *a, Stbl *b) )
    create a new sorted list

char *addstbl ( Stbl *stbl, char *key )
    add an element to a sorted list

void delstbl ( Stbl *stbl, char *key )
    delete an element from a sorted list

int freestbl ( Stbl *stbl, int (*free_stbl_val) () )
    free the resources for a sorted list


char *getstbl ( Stbl *stbl, int index )
    get an element from a sorted list

char *tststbl ( Stbl *stbl, char *key )
    test if an element exists in a sorted list


int maxstbl ( Stbl *stbl )
    returns the number of element in a sorted list

Tbl *tblstbl ( Stbl *stbl )
    returns the list of all elements in a sorted list


int applystbl ( Stbl *stbl, int (*function) (), void *pvt )
    apply a function to a sorted list


Stbl * newidmap ( void )
    create a new id map, mapping one set of positive integers to another

void freeidmap ( Stbl *map )
    free an id map

int idset ( Stbl *map, int key, int x )
    sets the value of key in map to x; any previous
    value for key is returned, or -1

int idget ( Stbl *map, int key )
    returns the value of key in map, or -1 if it's not set

<subsection Convenience Macros>
allot(type *, name, n)
    malloc space for n (type *) elements, putting the address in name

reallot(type *, name, n)
    realloc space for n (type *) elements, putting the address in name


    allot and reallot both use ALLOTERROR, which may be defined as ALLOTDIE (the default), ALLOTCOMPLAIN, or ALLOTREGISTER_ERROR, or your own macro 

SIZE_BUFFER(type *, buffer, sizevar, needed)
    ensure that (type *) buffer (currently allocated with size in sizevar) has space for at least needed elements -- if not, free the old buffer, and malloc a new buffer

RESIZE_BUFFER(type *, buffer, sizevar, needed)
    ensure that (type *) buffer (currently allocated with size in sizevar) has space for at least needed elements -- if not, realloc the old buffer, copying the current contents

private SQR(a)
    expands to (a)*(a) -- bad if a has side effects

private ABS(a)
    expands to ((a>=0)?(a):-(a)) -- bad if a has side effects

private SIGN(a)
    expands to (((a)>0)? 1.0 : ((a)<0) ? -1.0 : 0.0) -- bad if a has side effects

private MAX(a,b)
    expands to ((a>b)?(a):(b)) -- bad if a or b have side effects

private MIN(a,b)
    expands to ((a>b)?(b):(a)) -- bad if a or b have side effects

<subsection IEEE Arithmetic>

int is_infinity ( double x )
    returns 1 if x is infinity

int is_nan ( double x )
    returns 1 if x is nan

int is_negative_infinity ( double x );
    returns 1 if x is -infinity

double an_infinity ( void );
    returns an infinity

double a_nan ( void ) ;
    returns a (quiet) nan

double a_quiet_nan ( void );
    returns a quiet nan

double a_signaling_nan ( void );
    returns a signaling nan

<subsection Local Machine/Architecture>

int my_hardware(char *hdw)
    returns processor name (sparc, i386, ..)

int my_hostname(char *name)
    returns hostname 

int my_ip(char *hostname, char *ipc, long *ip)
    returns ip address, as integer and in dot notation

int my_os(char *name)
    returns operating system (Solaris, Linux, ...)
