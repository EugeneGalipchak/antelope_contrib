'\" te
.TH GCLRAYTRACE 3 "$Date$"
.SH NAME
GCLraytrace - ray path functions for use with GCLgrid objects 
.SH SYNOPSIS
.nf
#include "dmatrix.h"
#include "gclgrid.h"
#include "ray1d.h"
using namespace SEISPP;

class RayPathSphere
{
public:
        int npts;
	double p;
        double *r,*delta,*t;
        RayPathSphere(){r=NULL,delta=NULL,t=NULL;};
        RayPathSphere(int n)
        {npts=n; r=new double[n], delta=new double[n], t=new double[n];};
        // This fully parametrized version constructs a full path
        RayPathSphere(VelocityModel_1d& vm,
                double p, double zmax, double tmax, double del,
                const string mode);
        RayPathSphere(const RayPathSphere&);
        ~RayPathSphere(){if(r!=NULL)delete[]r;
                if(delta!=NULL)delete[]delta;
                if(t!=NULL)delete[]t;};
        void operator = (const RayPathSphere&);
	double depth(int ip);
};
dmatrix *GCLgrid_Ray_project_down(GCLgrid3d& grid, RayPathSphere& path,
     double theta, int ix1, int ix2, int ix3) throw(GCLgrid_error);
dmatrix *GCLgrid_Ray_project_up(GCLgrid3d& grid, RayPathSphere& path,
     double theta, int ix1, int ix2, int ix3) throw(GCLgrid_error);
dmatrix *GCLgrid_Ray_project(GCLgrid& grid, RayPathSphere& path,
     double theta, int ix1, int ix2) throw(GCLgrid_error);
.fi
.SH DESCRIPTION
.LP
Body wave imaging with ray theory based propagators requires computing
ray paths and path integrals along ray paths.  This set of objects and
helper functions work with GCLgrid(3) objects to accomplish this along
with the related function pathintegral(3).  
The methods used here depend on a form of approximate ray tracing 
where the rays are computed using a 1d earth model, but the concept is
that path integrals would normally be computed through a 3d earth model
defined by a GCLscalarfield3d object.  
Hence, these functions are of primary use for teleseismic P wave imaging
where this approximation is, as far as we know, relatively good most of 
the time.
.LP
The RayPathSphere object defines a reference ray path for a 1d reference
model.  The path is defined by the three parallel vectors r, delta, and t
of length npts.  r, delta, and t define radius, accumulated distance (in radians),
and time (in seconds) for the path.  The time in the object is 
computed from the 1D earth model from which the ray was generated.
Note the path always starts at earth's surface and
defines a curve directed downward into the earth.  
Further note that radius values are based on a spherical earth with a 
standard radius of 6378.17 km.  
The depth function is supplied to provide a datum less sensitive to this
fixed parameter.  
The ray parameter used to generate the ray is stored in the object
as the variable p.  Be warned it has units of radians/s since this is spherical
earth geometry.  
.SH CONSTRUCTORS
.LP
The main constructor that should be used is the fully parameterized 
constructor containing the VelocityModel_1d object with the name
vmod.  A simple unparameterized constructor and one with a size parameter,
n, are defined but should not normally be used.
.LP
The fully parameterized constructor uses a 1D earth model defined by
vmod.  It does not know about P and S waves, only velocities.  
That is, it simply applies standard 1d ray trace equations to the earth model
defined by vmod and traces a ray with ray parameter p.  An 
IMPORTANT warning is that the input ray parameter to this constructor
is in units of s/km while the ray parameter stored with the object
is the conversion to s/radian.  This was intentional since s/radians
make no sense to a human user, but are appropriate for the object
definition seen mainly by the machine.  The ray path generated by
this constructor starts at the surface and increments downward in 
one of two formats defined by the mode variable.  When mode is "z"
the ray is aimed to produce steps uniform in z at interval del
until a depth of zmax is reached.
When mode is "t" the ray is computed to produce (approximate) equal
times steps of size del until the time of tmax is exceeded. 
A ray tracer has to handle the singular case of a turning ray.  
This is handled in a simple way by simply stopping the ray tracing
when the next step would produce a horizontal ray (singular
radical in the integration formula) and setting the number of
points for the truncated path.  The constructor does NOT throw
an exception in this case, but only issues a warning message to cerr.  
I considered this sensible since this is not really an error and 
that case should be handled in a different way.  Furthermore, 
constructors normally discard data they are constructing if they
throw an exception, which is not a desirable behaviour in this case.
.SH HELPERS
.LP
The primary use of a RayPathSphere object is as input to the three
helper functions:  \fIGCLgrid_Ray_project_down, GCLgrid_Ray_project_up\fR, and 
\fIGCLgrid_Ray_project\fR.  
\fIGCLgrid_Ray_project_down\fR and \fIGCLgrid_Ray_project_up\fR take a ray 
defined by a RayPathSphere object, path, and essentially translate it
to the point in space defined by the GCLgrid3d position on the earth
associated with the grid index position (ix1,ix2,ix3).  An output raypath
is created directed at the angle theta (local geographic azimuth at that
latitude and longitude).  The "up" version creates a path from the point
(ix1,ix2,ix3) to earth's surface and the "down" version creates a path from
that point to the bottom end of the input ray definition.  
In both cases when the path begins exactly at the grid point defined
by (ix1,ix2,ix3)  be warned that the first path vector defined by 
the jump from point 0 to point 1 may be very small and should not 
be used for gradient calculations as it is subject to divide by
zero errors.  
.LP
The \fIGCLgrid_Ray_project\fR function does the same thing as the 
previously described functions but for a 2D
reference grid.  There is no up and down version in this case because
it is assumed there is only a down case.  That is, although a GCLgrid could
define a buried surface, the assumption here is that the points are at or
near earth's surface.  Because it uses only a 2D grid only the ix1 and
ix2 index positions are needed.  
.LP
All of these functions return a pointer to a newly allocated dmatrix object.
This matrix contains a 3XN matrix (You can get the number of points in the path 
with the columns() member of the dmatrix(3) object.) that defines the 
path in the Cartesian reference frame of the GCLgrid or GCLgrid3d object
passed to the function.  (row 0=x1, row 1=x2, and row 2 = x3)  
Note that because this matrix is created by these functions it needs to be
deleted when you are finished with it to avoid a memory leak.
.SH EXCEPTIONS
.LP
The GCLgrid_Ray_project functions will throw a GCLgrid_error object if 
the requested indices are invalid or if the ray path and grid are 
inconsistent.  If thrown these errors indicate a programming error
that needs to be fixed.
.LP
The depth member function of the RayPathSphere object will throw
a SeisppError if the requested depth index position is outside
the range of the ray defined in the object.
.SH LIBRARY
-lgclgrid -lseispp
.SH "SEE ALSO"
.nf
gclgrid(3), dmatrix(3), pathintegral(3), SeisppError(3),
http://seismo.geology.indiana.edu/~pavlis/seispp/seispp/
.fi
.SH AUTHOR
.nf
Gary L. Pavlis
Department of Geological Sciences
Indiana University
pavlis@indiana.edu
.fi
.\" $Id$
